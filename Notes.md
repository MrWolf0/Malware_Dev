# Notes about PE file 
This file type is specific to the Windows operating system and known as PE portable executable that is mean it's portable because it contains information, resources, and references to dynamic-linked libraries (DLL) that allows windows to load and execute the machine code.<br>
Every application when start a process in user-mode it reserves two types of memory private virtual address space and handle table.<br>
**Private Virtual Address Space:**
This is the range of virtual memory addresses that the process can use. It's private to the process, meaning other processes cannot access this memory directly. This virtual address space includes the memory used for the process's code, data, stack, and heap.<br>
**Handle Table:**
This is a table maintained by the operating system to keep track of resources that the process has opened, such as files, windows, and synchronization objects. Each handle in the table provides a reference to a resource, allowing the process to interact with it.<br>
think about the PE as a book that has data which are the content of the book and the idea of why the author write that book. And we have the metadata of that book such as title, author's name, publisher, date and etc.<br>
PE is the same idea has header(metadata) and section(data). <br>
In section part we have some other sections such as <br>
1.text section : which contain executable code.<br>
2.rdata section : which contain read only data.<br>
3.data section : which contain Initialized data such as functions declaration and variables.<br>
4.pdata section : which contain Exception information which contains an array of function table entries that are used for exception handling. It is pointed to by the exception table entry in the image data directory(one of PE's headers).<br>
5.rsrc section : which contain Resource directory which contains PE's resources such as Manifest file, icons and loaded files or libs.<br>
6.reloc section : which contain Image relocations it allows to windows loader to safely load dlls that PE needs to run its operations.<br>
we can use a tool in visual stdio's cmd called dumpbin as following<br>
```dumpbin /headers c:\windows\system32\calc.exe
```
this commend print out all metadata of that binary file and its headers.

**Difference between EXE and DLL**
EXE is an independent process which can be loaded in memory independently without any other resources.EXE files are executable programs. They are designed to be run directly by the operating system. When you double-click an EXE file, it starts a new process. Standalone Execution: EXE files are standalone and contain all the code and resources needed to run a program. They can also call functions and use resources from DLLs.<br>
DLL files are libraries that contain code and data that can be used by multiple programs simultaneously. They are not meant to be executed on their own but are intended to be loaded and used by other programs (EXEs or other DLLs).
DLL files do not have a standard entry point. Instead, they export functions that other applications can call. They often have an entry point function like DllMain, which is used by the operating system to manage initialization and cleanup tasks and can be loaded to an existence running process or a program and can't loaded into memory independently.<br>
Shared Code: DLLs allow code to be reused across different programs. They help in modularizing applications, reducing code duplication, and managing updates more effectively.<br>
EXE: Used to execute programs directly; contains entry points and can run independently.<br>
DLL: Used to provide shared code and resources to other programs; does not run independently and provides functions to be called by other code.<br>

* [SSRF_Lab3.py](./SSRF_Lab3.py)

**SSRF with blacklist-based input filter**

T
* __Decimal representation__ <[decimal](https://www.ipaddressguide.com/ip)>
* __Octal representation__ <[octal](https://www.browserling.com/tools/ip-to-oct)>
* __Hexadecimal representation__ <[hex](https://www.browserling.com/tools/ip-to-hex)>

* [SSRF_Lab4.py](./SSRF_Lab4.py)

**SSRF with whitelist-based input filter**


**Python use (urllib.parse) ex :**<br>
```
from urllib.parse import urlparse

url = "http://username@stock.weliketoshop.net:8080/path?query=value#fragment"
parsed_url = urlparse(url)

print("Scheme:", parsed_url.scheme)
print("User Info:", parsed_url.username)  # Note: urllib.parse.urlparse does not provide a direct user info attribute
print("Host:", parsed_url.hostname)
print("Port:", parsed_url.port)
print("Path:", parsed_url.path)
print("Query:", parsed_url.query)
print("Fragment:", parsed_url.fragment)
```

**Java use (java.net.URI and java.net.URL) ex :**
```
import java.net.URI;

public class URIDemo {
    public static void main(String[] args) throws Exception {
        URI uri = new URI("http://username@stock.weliketoshop.net:8080/path?query=value#fragment");
        
        System.out.println("Scheme: " + uri.getScheme());
        System.out.println("User Info: " + uri.getUserInfo());
        System.out.println("Host: " + uri.getHost());
        System.out.println("Port: " + uri.getPort());
        System.out.println("Path: " + uri.getPath());
        System.out.println("Query: " + uri.getQuery());
        System.out.println("Fragment: " + uri.getFragment());
    }
}

```

**PHP use (parse_url) ex :**<br>
```
<?php
$url = "http://username@stock.weliketoshop.net:8080/path?query=value#fragment";
$parsed_url = parse_url($url);

echo "Scheme: " . $parsed_url['scheme'] . PHP_EOL;
echo "User Info: " . $parsed_url['user'] . PHP_EOL; // Note: parse_url does not directly provide user_info
echo "Host: " . $parsed_url['host'] . PHP_EOL;
echo "Port: " . $parsed_url['port'] . PHP_EOL;
echo "Path: " . $parsed_url['path'] . PHP_EOL;
echo "Query: " . $parsed_url['query'] . PHP_EOL;
echo "Fragment: " . $parsed_url['fragment'] . PHP_EOL;
?>
```







* __Nasser El-Din Basha my github__ <[MrWolf0](https://github.com/MrWolf0)>
* __Nasser El-Din Basha my linkedin__ <[mrwolf0](https://www.linkedin.com/in/mrwolf0)>
